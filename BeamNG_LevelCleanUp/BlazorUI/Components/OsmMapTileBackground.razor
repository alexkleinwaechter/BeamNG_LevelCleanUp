@using System.Globalization
@using BeamNgTerrainPoc.Terrain.GeoTiff

@* 
    Reusable OSM map tile background component.
    Renders OpenStreetMap tiles as a background layer for geographic visualizations.
    Can be used in CropAnchorSelector, OsmFeaturePreview, or any component that needs a map background.
*@

@if (IsVisible && BoundingBox != null && DisplayWidth > 0 && DisplayHeight > 0)
{
    <div class="osm-tile-container" style="@GetContainerStyle()">
        @foreach (var tile in GetVisibleTiles())
        {
            <img src="@tile.Url" 
                 alt="OSM Tile"
                 class="osm-tile"
                 style="@tile.Style"
                 loading="lazy"
                 @onerror="@(() => { /* Tile failed to load, ignore */ })" />
        }
    </div>
    
    @if (ShowAttribution)
    {
        <div class="osm-attribution" style="@GetAttributionStyle()">
            © <a href="https://www.openstreetmap.org/copyright" target="_blank">OpenStreetMap</a>
        </div>
    }
}

<style>
    .osm-tile-container {
        position: absolute;
        top: 0;
        left: 0;
        overflow: hidden;
        pointer-events: none;
    }
    
    .osm-tile {
        position: absolute;
        pointer-events: none;
    }
    
    .osm-attribution {
        position: absolute;
        font-size: 9px;
        color: #666;
        background: rgba(255, 255, 255, 0.7);
        padding: 1px 4px;
        border-radius: 2px;
        pointer-events: auto;
    }
    
    .osm-attribution a {
        color: #0078a8;
        text-decoration: none;
    }
    
    .osm-attribution a:hover {
        text-decoration: underline;
    }
</style>

@code {
    private const int OsmTileSize = 256;
    
    /// <summary>
    /// The geographic bounding box to display tiles for.
    /// </summary>
    [Parameter]
    public GeoBoundingBox? BoundingBox { get; set; }
    
    /// <summary>
    /// Display width in pixels.
    /// </summary>
    [Parameter]
    public int DisplayWidth { get; set; }
    
    /// <summary>
    /// Display height in pixels.
    /// </summary>
    [Parameter]
    public int DisplayHeight { get; set; }
    
    /// <summary>
    /// Whether the map tiles are visible.
    /// </summary>
    [Parameter]
    public bool IsVisible { get; set; } = true;
    
    /// <summary>
    /// Opacity of the tiles (0.0 to 1.0).
    /// </summary>
    [Parameter]
    public float Opacity { get; set; } = 0.85f;
    
    /// <summary>
    /// Whether to show the OpenStreetMap attribution.
    /// </summary>
    [Parameter]
    public bool ShowAttribution { get; set; } = true;
    
    /// <summary>
    /// Position of the attribution text: "top-left", "top-right", "bottom-left", "bottom-right".
    /// </summary>
    [Parameter]
    public string AttributionPosition { get; set; } = "bottom-right";
    
    /// <summary>
    /// Maximum number of tiles to load (to prevent performance issues).
    /// </summary>
    [Parameter]
    public int MaxTiles { get; set; } = 25;
    
    /// <summary>
    /// Z-index for the tile container.
    /// </summary>
    [Parameter]
    public int ZIndex { get; set; } = 0;

    private string GetContainerStyle()
    {
        return $"width: {DisplayWidth}px; height: {DisplayHeight}px; z-index: {ZIndex};";
    }
    
    private string GetAttributionStyle()
    {
        return AttributionPosition switch
        {
            "top-left" => "top: 2px; left: 2px;",
            "top-right" => "top: 2px; right: 2px;",
            "bottom-left" => "bottom: 2px; left: 2px;",
            "bottom-right" => "bottom: 2px; right: 2px;",
            _ => "bottom: 2px; right: 2px;"
        };
    }

    /// <summary>
    /// Represents a single OSM tile to render.
    /// </summary>
    private record OsmTileInfo(string Url, string Style);

    /// <summary>
    /// Gets the list of OSM tiles needed to cover the bounding box.
    /// </summary>
    private List<OsmTileInfo> GetVisibleTiles()
    {
        var tiles = new List<OsmTileInfo>();
        
        if (BoundingBox == null || DisplayWidth <= 0 || DisplayHeight <= 0)
            return tiles;

        var bbox = BoundingBox;

        // Calculate optimal zoom level based on the bounding box size and display size
        var zoom = CalculateOptimalZoom(bbox, DisplayWidth, DisplayHeight);
        
        // Clamp zoom to reasonable levels
        zoom = Math.Clamp(zoom, 1, 18);

        // Get tile coordinates for the bounding box corners
        var (minTileX, minTileY) = LatLonToTile(bbox.MaxLatitude, bbox.MinLongitude, zoom);
        var (maxTileX, maxTileY) = LatLonToTile(bbox.MinLatitude, bbox.MaxLongitude, zoom);

        // Limit the number of tiles to prevent performance issues
        var tileCountX = maxTileX - minTileX + 1;
        var tileCountY = maxTileY - minTileY + 1;
        
        if (tileCountX * tileCountY > MaxTiles)
        {
            // Too many tiles, reduce zoom level
            zoom = Math.Max(1, zoom - 2);
            (minTileX, minTileY) = LatLonToTile(bbox.MaxLatitude, bbox.MinLongitude, zoom);
            (maxTileX, maxTileY) = LatLonToTile(bbox.MinLatitude, bbox.MaxLongitude, zoom);
        }

        // Calculate how the tile grid maps to display pixels
        var bboxLonRange = bbox.MaxLongitude - bbox.MinLongitude;
        var bboxLatRange = bbox.MaxLatitude - bbox.MinLatitude;

        for (var tileY = minTileY; tileY <= maxTileY; tileY++)
        {
            for (var tileX = minTileX; tileX <= maxTileX; tileX++)
            {
                // Get the geographic bounds of this tile
                var (tileSouthLat, tileWestLon) = TileToLatLon(tileX, tileY + 1, zoom);
                var (tileNorthLat, tileEastLon) = TileToLatLon(tileX + 1, tileY, zoom);

                // Calculate position in display pixels relative to the container
                var leftPx = (tileWestLon - bbox.MinLongitude) / bboxLonRange * DisplayWidth;
                var topPx = (bbox.MaxLatitude - tileNorthLat) / bboxLatRange * DisplayHeight;
                var tileLonSpan = tileEastLon - tileWestLon;
                var tileLatSpan = tileNorthLat - tileSouthLat;
                var widthPx = tileLonSpan / bboxLonRange * DisplayWidth;
                var heightPx = tileLatSpan / bboxLatRange * DisplayHeight;

                // Build tile URL (using OpenStreetMap tile server)
                var url = $"https://tile.openstreetmap.org/{zoom}/{tileX}/{tileY}.png";
                
                // Build CSS style for positioning
                var style = string.Format(CultureInfo.InvariantCulture,
                    "left: {0:F1}px; top: {1:F1}px; width: {2:F1}px; height: {3:F1}px; opacity: {4:F2};",
                    leftPx, topPx, widthPx, heightPx, Opacity);

                tiles.Add(new OsmTileInfo(url, style));
            }
        }

        return tiles;
    }

    /// <summary>
    /// Calculates the optimal zoom level to fit the bounding box in the display area.
    /// </summary>
    private static int CalculateOptimalZoom(GeoBoundingBox bbox, int displayWidth, int displayHeight)
    {
        var lonSpan = bbox.MaxLongitude - bbox.MinLongitude;
        var latSpan = bbox.MaxLatitude - bbox.MinLatitude;

        // Calculate zoom for longitude
        var zoomLon = Math.Log2(360.0 / lonSpan * displayWidth / OsmTileSize);
        
        // Calculate zoom for latitude (using Mercator projection approximation)
        var centerLat = (bbox.MinLatitude + bbox.MaxLatitude) / 2.0;
        var latRadians = centerLat * Math.PI / 180.0;
        var mercatorLatSpan = Math.Log(Math.Tan(Math.PI / 4 + latRadians / 2)) - 
                              Math.Log(Math.Tan(Math.PI / 4 + (centerLat - latSpan / 2) * Math.PI / 180.0 / 2));
        var worldMercatorHeight = 2 * Math.PI;
        var zoomLat = Math.Log2(worldMercatorHeight / Math.Abs(mercatorLatSpan) * displayHeight / OsmTileSize);

        return (int)Math.Floor(Math.Min(zoomLon, zoomLat));
    }

    /// <summary>
    /// Converts latitude/longitude to OSM tile coordinates.
    /// </summary>
    private static (int tileX, int tileY) LatLonToTile(double lat, double lon, int zoom)
    {
        var n = Math.Pow(2, zoom);
        var tileX = (int)Math.Floor((lon + 180.0) / 360.0 * n);
        var latRad = lat * Math.PI / 180.0;
        var tileY = (int)Math.Floor((1.0 - Math.Log(Math.Tan(latRad) + 1.0 / Math.Cos(latRad)) / Math.PI) / 2.0 * n);
        
        tileX = Math.Clamp(tileX, 0, (int)n - 1);
        tileY = Math.Clamp(tileY, 0, (int)n - 1);
        
        return (tileX, tileY);
    }

    /// <summary>
    /// Converts OSM tile coordinates to latitude/longitude (northwest corner of tile).
    /// </summary>
    private static (double lat, double lon) TileToLatLon(int tileX, int tileY, int zoom)
    {
        var n = Math.Pow(2, zoom);
        var lon = tileX / n * 360.0 - 180.0;
        var latRad = Math.Atan(Math.Sinh(Math.PI * (1.0 - 2.0 * tileY / n)));
        var lat = latRad * 180.0 / Math.PI;
        return (lat, lon);
    }
}
