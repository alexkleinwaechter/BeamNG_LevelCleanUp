@using System.Text.RegularExpressions
@using BeamNG_LevelCleanUp.Communication
@using BeamNG_LevelCleanUp.Objects
@using BeamNG_LevelCleanUp.Utils
@using BeamNgTerrainPoc.Terrain.Models
@using static BeamNG_LevelCleanUp.BlazorUI.Components.TerrainMaterialSettings
@inject ISnackbar Snackbar

<MudPaper Class="@CssClass" Elevation="2">
    <MudStack Row="true" Justify="Justify.SpaceBetween" AlignItems="AlignItems.Center">
        <div>
            <MudText Typo="Typo.h6" Class="mb-1">
                <MudIcon Icon="@Icons.Material.Filled.FileUpload" Class="mr-2" />
                Import BeamNG Terrain Preset
            </MudText>
            <MudText Typo="Typo.body2" Color="Color.Secondary">
                Load settings from a BeamNG terrain preset file (*_terrainPreset.json).
                This will set heightmap, terrain size, and layer map assignments.
            </MudText>
        </div>
        <MudButton Variant="Variant.Filled"
                   Color="Color.Secondary"
                   StartIcon="@Icons.Material.Filled.Upload"
                   OnClick="SelectAndImportPreset">
            Import Preset
        </MudButton>
    </MudStack>
    @if (!string.IsNullOrEmpty(PresetFilePath))
    {
        <MudAlert Severity="Severity.Success" Class="mt-3" Dense="true">
            <strong>Preset loaded:</strong> @Path.GetFileName(PresetFilePath)
        </MudAlert>
        <MudText Typo="Typo.caption" Color="Color.Secondary" Class="mt-1">
            Layer maps assigned: @Materials.Count(m => m.HasLayerMap) / @Materials.Count materials
            @if (!string.IsNullOrEmpty(HoleMapPath))
            {
                <text> | Hole map: ?</text>
            }
        </MudText>
    }
</MudPaper>

@code {
/// <summary>
/// Additional CSS classes to apply to the component.
/// </summary>
[Parameter]
public string? Class { get; set; }

private string CssClass => string.IsNullOrEmpty(Class) ? "pa-4" : $"pa-4 {Class}";

/// <summary>
/// The list of terrain materials to assign layer maps to.
/// </summary>
[Parameter]
public List<TerrainMaterialItemExtended> Materials { get; set; } = new();

    /// <summary>
    /// The working directory of the level (used for path resolution fallback).
    /// </summary>
    [Parameter]
    public string WorkingDirectory { get; set; } = string.Empty;

    /// <summary>
    /// Callback when preset import is complete with the imported settings.
    /// </summary>
    [Parameter]
    public EventCallback<TerrainPresetResult> OnPresetImported { get; set; }

    /// <summary>
    /// The path to the loaded preset file (for display).
    /// </summary>
    public string? PresetFilePath { get; private set; }

    /// <summary>
    /// The resolved hole map path (if found).
    /// </summary>
    public string? HoleMapPath { get; private set; }

    private string? _presetDirectory;

    private async Task SelectAndImportPreset()
    {
        string? selectedPath = null;
        var staThread = new Thread(() =>
        {
            using var dialog = new OpenFileDialog();
            dialog.Filter = "Terrain Preset (*_terrainPreset.json)|*_terrainPreset.json|All JSON Files (*.json)|*.json";
            dialog.Title = "Select BeamNG Terrain Preset";
            if (dialog.ShowDialog() == System.Windows.Forms.DialogResult.OK) 
                selectedPath = dialog.FileName;
        });
        staThread.SetApartmentState(ApartmentState.STA);
        staThread.Start();
        staThread.Join();

        if (!string.IsNullOrEmpty(selectedPath))
        {
            await ImportTerrainPreset(selectedPath);
        }
    }

    private async Task ImportTerrainPreset(string presetPath)
    {
        try
        {
            PresetFilePath = presetPath;
            _presetDirectory = Path.GetDirectoryName(presetPath);

            var jsonContent = await File.ReadAllTextAsync(presetPath);
            var jsonNode = JsonUtils.GetValidJsonNodeFromString(jsonContent, presetPath);

            if (jsonNode == null)
            {
                Snackbar.Add("Failed to parse terrain preset JSON.", Severity.Error);
                return;
            }

            var result = new TerrainPresetResult();

            // Extract terrain name
            var terrainName = jsonNode["name"]?.GetValue<string>();
            if (!string.IsNullOrEmpty(terrainName))
            {
                result.TerrainName = terrainName;
            }

            // Extract heightScale (maps to maxHeight)
            if (jsonNode["heightScale"] != null)
            {
                result.MaxHeight = jsonNode["heightScale"]!.GetValue<float>();
            }

            // Extract squareSize (maps to metersPerPixel)
            if (jsonNode["squareSize"] != null)
            {
                result.MetersPerPixel = jsonNode["squareSize"]!.GetValue<float>();
            }

            // Extract base height from pos.z
            if (jsonNode["pos"]?["z"] != null)
            {
                result.TerrainBaseHeight = jsonNode["pos"]!["z"]!.GetValue<float>();
            }

            // Resolve heightmap path
            var heightMapPath = jsonNode["heightMapPath"]?.GetValue<string>();
            if (!string.IsNullOrEmpty(heightMapPath))
            {
                var resolvedHeightmap = ResolvePresetFilePath(heightMapPath);
                if (File.Exists(resolvedHeightmap))
                {
                    result.HeightmapPath = resolvedHeightmap;
                    PubSubChannel.SendMessage(PubSubMessageType.Info, $"Heightmap found: {result.HeightmapPath}");
                }
                else
                {
                    PubSubChannel.SendMessage(PubSubMessageType.Warning, $"Heightmap not found at: {resolvedHeightmap}");
                }
            }

            // Resolve holemap path
            var holeMapPath = jsonNode["holeMapPath"]?.GetValue<string>();
            if (!string.IsNullOrEmpty(holeMapPath))
            {
                var resolvedHolemap = ResolvePresetFilePath(holeMapPath);
                if (File.Exists(resolvedHolemap))
                {
                    HoleMapPath = resolvedHolemap;
                    result.HoleMapPath = resolvedHolemap;
                    PubSubChannel.SendMessage(PubSubMessageType.Info, $"Holemap found: {HoleMapPath}");
                }
            }

            // Process opacity maps (layer maps)
            var opacityMaps = jsonNode["opacityMaps"]?.AsArray();
            if (opacityMaps != null)
            {
                var assignedCount = 0;
                var notFoundCount = 0;
                var orderUpdatedCount = 0;

                foreach (var mapPath in opacityMaps)
                {
                    var mapPathStr = mapPath?.GetValue<string>();
                    if (string.IsNullOrEmpty(mapPathStr)) continue;

                    var resolvedPath = ResolvePresetFilePath(mapPathStr);
                    var (order, materialName) = ParseLayerMapFileName(Path.GetFileName(mapPathStr));

                    if (order.HasValue && !string.IsNullOrEmpty(materialName))
                    {
                        // Try to match with existing terrain materials
                        var matchedMaterial = FindMatchingMaterial(materialName, order.Value);

                        if (matchedMaterial != null)
                        {
                            if (File.Exists(resolvedPath))
                            {
                                matchedMaterial.LayerMapPath = resolvedPath;
                                
                                // CRITICAL: Update the material order to match the preset order
                                // The order in the preset filename is the index used in the binary .ter file
                                if (matchedMaterial.Order != order.Value)
                                {
                                    PubSubChannel.SendMessage(PubSubMessageType.Info,
                                        $"Updating order for '{matchedMaterial.InternalName}': {matchedMaterial.Order} -> {order.Value}");
                                    matchedMaterial.Order = order.Value;
                                    orderUpdatedCount++;
                                }
                                
                                assignedCount++;
                            }
                            else
                            {
                                notFoundCount++;
                                PubSubChannel.SendMessage(PubSubMessageType.Warning,
                                    $"Layer map file not found: {resolvedPath}");
                            }
                        }
                        else
                        {
                            PubSubChannel.SendMessage(PubSubMessageType.Warning,
                                $"No matching material found for: {materialName} (order {order})");
                        }
                    }
                }

                // After processing all opacity maps, re-sort materials by their new order
                if (orderUpdatedCount > 0)
                {
                    // Sort the Materials list by Order to reflect preset order
                    var sorted = Materials.OrderBy(m => m.Order).ToList();
                    Materials.Clear();
                    Materials.AddRange(sorted);
                    
                    PubSubChannel.SendMessage(PubSubMessageType.Info,
                        $"Reordered {orderUpdatedCount} material(s) to match preset order");
                }

                result.AssignedLayerMapsCount = assignedCount;
                PubSubChannel.SendMessage(PubSubMessageType.Info,
                    $"Preset import complete: {assignedCount} layer maps assigned" +
                    (orderUpdatedCount > 0 ? $", {orderUpdatedCount} materials reordered" : "") +
                    (notFoundCount > 0 ? $", {notFoundCount} files not found" : ""));
            }

            // Import road smoothing settings for materials that have preset files
            var roadSmoothingImported = await ImportRoadSmoothingPresets(result.TerrainName);
            if (roadSmoothingImported > 0)
            {
                PubSubChannel.SendMessage(PubSubMessageType.Info,
                    $"Imported {roadSmoothingImported} road smoothing preset(s)");
            }

            await OnPresetImported.InvokeAsync(result);
            Snackbar.Add($"Terrain preset imported: {result.TerrainName}", Severity.Success);
            StateHasChanged();
        }
        catch (Exception ex)
        {
            var message = ex.InnerException != null ? ex.Message + $" {ex.InnerException}" : ex.Message;
            Snackbar.Add($"Error importing preset: {message}", Severity.Error);
            PubSubChannel.SendMessage(PubSubMessageType.Error, $"Preset import error: {message}");
        }
    }

    /// <summary>
    /// Resolves a BeamNG relative path (like "/levels/kattenes/import/...") to an absolute file path.
    /// First tries the preset directory, then uses working directory as fallback.
    /// </summary>
    private string ResolvePresetFilePath(string beamngPath)
    {
        // Extract just the filename
        var fileName = Path.GetFileName(beamngPath);

        // First, try the preset directory (where the *_terrainPreset.json was loaded from)
        if (!string.IsNullOrEmpty(_presetDirectory))
        {
            var presetDirPath = Path.Combine(_presetDirectory, fileName);
            if (File.Exists(presetDirPath))
            {
                return presetDirPath;
            }
        }

        // Try to resolve from working directory using the full relative path
        if (!string.IsNullOrEmpty(WorkingDirectory))
        {
            // Try multiple patterns:
            // 1. Direct path in working directory
            var directPath = Path.Combine(WorkingDirectory, fileName);
            if (File.Exists(directPath))
            {
                return directPath;
            }

            // 2. If path contains /import/, look in import subfolder
            if (beamngPath.Contains("/import/"))
            {
                var importPath = Path.Combine(WorkingDirectory, "import", fileName);
                if (File.Exists(importPath))
                {
                    return importPath;
                }
            }

            // 3. Try to reconstruct relative path from levels/levelname/...
            var match = Regex.Match(beamngPath, @"/levels/[^/]+/(.+)");
            if (match.Success)
            {
                var relativePath = match.Groups[1].Value.Replace('/', Path.DirectorySeparatorChar);
                var reconstructedPath = Path.Combine(WorkingDirectory, relativePath);
                if (File.Exists(reconstructedPath))
                {
                    return reconstructedPath;
                }
            }
        }

        // Return best guess path (preset directory + filename)
        if (!string.IsNullOrEmpty(_presetDirectory))
        {
            return Path.Combine(_presetDirectory, fileName);
        }

        return beamngPath;
    }

    /// <summary>
    /// Parses a layer map filename like "theTerrain_layerMap_12_BeamNG_DriverTrainingETK_Asphalt.png"
    /// Returns the order index and material name.
    /// </summary>
    private (int? order, string? materialName) ParseLayerMapFileName(string fileName)
    {
        // Pattern: {terrainName}_layerMap_{order}_{materialName}.png
        var match = Regex.Match(fileName, @"^.+_layerMap_(\d+)_(.+)\.png$", RegexOptions.IgnoreCase);

        if (match.Success && int.TryParse(match.Groups[1].Value, out var order))
        {
            return (order, match.Groups[2].Value);
        }

        return (null, null);
    }

    /// <summary>
    /// Finds a matching terrain material by name, with fuzzy matching for level name prefixes/suffixes.
    /// </summary>
    private TerrainMaterialItemExtended? FindMatchingMaterial(string layerMaterialName, int presetOrder)
    {
        // Normalize the layer material name
        var normalizedLayerName = NormalizeMaterialName(layerMaterialName);

        // Try exact match first (case-insensitive)
        var exactMatch = Materials.FirstOrDefault(m =>
            string.Equals(m.InternalName, layerMaterialName, StringComparison.OrdinalIgnoreCase) ||
            string.Equals(m.MaterialName, layerMaterialName, StringComparison.OrdinalIgnoreCase));

        if (exactMatch != null)
        {
            return exactMatch;
        }

        // Try normalized match (strips level name prefixes like "BeamNG_DriverTrainingETK_")
        var normalizedMatch = Materials.FirstOrDefault(m =>
        {
            var normalizedInternalName = NormalizeMaterialName(m.InternalName);
            var normalizedMaterialName = NormalizeMaterialName(m.MaterialName);

            return string.Equals(normalizedInternalName, normalizedLayerName, StringComparison.OrdinalIgnoreCase) ||
                   string.Equals(normalizedMaterialName, normalizedLayerName, StringComparison.OrdinalIgnoreCase);
        });

        if (normalizedMatch != null)
        {
            return normalizedMatch;
        }

        // Try suffix match (e.g., "_Asphalt" in "BeamNG_DriverTrainingETK_Asphalt")
        var suffixMatch = Materials.FirstOrDefault(m =>
        {
            // Check if either ends with the layer name (ignoring case)
            return m.InternalName.EndsWith(layerMaterialName, StringComparison.OrdinalIgnoreCase) ||
                   m.MaterialName.EndsWith(layerMaterialName, StringComparison.OrdinalIgnoreCase) ||
                   layerMaterialName.EndsWith(m.InternalName, StringComparison.OrdinalIgnoreCase) ||
                   layerMaterialName.EndsWith(m.MaterialName, StringComparison.OrdinalIgnoreCase);
        });

        if (suffixMatch != null)
        {
            return suffixMatch;
        }

        // Try contains match as last resort
        var containsMatch = Materials.FirstOrDefault(m =>
        {
            return m.InternalName.Contains(normalizedLayerName, StringComparison.OrdinalIgnoreCase) ||
                   normalizedLayerName.Contains(NormalizeMaterialName(m.InternalName), StringComparison.OrdinalIgnoreCase);
        });

        if (containsMatch != null)
        {
            return containsMatch;
        }

        // Try matching by order if it's within bounds
        if (presetOrder >= 0 && presetOrder < Materials.Count)
        {
            var orderMatch = Materials.FirstOrDefault(m => m.Order == presetOrder);
            if (orderMatch != null)
            {
                PubSubChannel.SendMessage(PubSubMessageType.Info,
                    $"Matched '{layerMaterialName}' to '{orderMatch.InternalName}' by order ({presetOrder})");
                return orderMatch;
            }
        }

        return null;
    }

    /// <summary>
    /// Normalizes a material name by removing common prefixes like level names.
    /// Examples:
    ///   "BeamNG_DriverTrainingETK_Asphalt" -> "Asphalt"
    ///   "Grass_driver_training" -> "Grass"
    /// </summary>
    private string NormalizeMaterialName(string name)
    {
        if (string.IsNullOrEmpty(name)) return name;

        // Remove common BeamNG prefixes
        var patterns = new[]
        {
            @"^BeamNG_[^_]+_",      // BeamNG_LevelName_
            @"^[^_]+_[^_]+_",       // Generic_Prefix_
            @"_[^_]+$"              // _suffix (like _driver_training)
        };

        var result = name;
        foreach (var pattern in patterns)
        {
            var normalized = Regex.Replace(result, pattern, "", RegexOptions.IgnoreCase);
            if (!string.IsNullOrEmpty(normalized) && normalized.Length >= 3)
            {
                result = normalized;
            }
        }

        return result;
    }

    /// <summary>
    /// Resets the component state.
    /// </summary>
    public void Reset()
    {
        PresetFilePath = null;
        HoleMapPath = null;
        _presetDirectory = null;
        StateHasChanged();
    }

    /// <summary>
    /// Imports road smoothing presets for all materials that have matching preset files in the preset directory.
    /// </summary>
    private async Task<int> ImportRoadSmoothingPresets(string? terrainName)
    {
        if (string.IsNullOrEmpty(_presetDirectory))
            return 0;

        var importedCount = 0;

        foreach (var material in Materials)
        {
            // Look for road smoothing preset file matching this material
            var presetFile = FindRoadSmoothingPresetFile(terrainName, material);
            
            if (!string.IsNullOrEmpty(presetFile) && File.Exists(presetFile))
            {
                var success = await ImportRoadSmoothingForMaterial(presetFile, material);
                if (success)
                {
                    importedCount++;
                    PubSubChannel.SendMessage(PubSubMessageType.Info,
                        $"Imported road smoothing settings for '{material.InternalName}'");
                }
            }
        }

        return importedCount;
    }

    /// <summary>
    /// Finds a road smoothing preset file for the given material.
    /// Searches for patterns like: *_roadSmoothing_*_{materialName}.json
    /// </summary>
    private string? FindRoadSmoothingPresetFile(string? terrainName, TerrainMaterialItemExtended material)
    {
        if (string.IsNullOrEmpty(_presetDirectory))
            return null;

        var sanitizedName = SanitizeFileName(material.InternalName);

        // Try exact match with terrain name and material name
        if (!string.IsNullOrEmpty(terrainName))
        {
            // Pattern: {terrainName}_roadSmoothing_{order}_{materialName}.json
            var files = Directory.GetFiles(_presetDirectory, $"{terrainName}_roadSmoothing_*_{sanitizedName}.json");
            if (files.Length > 0)
                return files[0];
        }

        // Search for any road smoothing file that ends with the material name
        try
        {
            var allFiles = Directory.GetFiles(_presetDirectory, "*_roadSmoothing_*.json");
            foreach (var file in allFiles)
            {
                var fileName = Path.GetFileNameWithoutExtension(file);
                
                // Check if filename ends with the material name (after the last underscore in _roadSmoothing_X_MaterialName)
                if (fileName.EndsWith($"_{sanitizedName}", StringComparison.OrdinalIgnoreCase) ||
                    fileName.EndsWith($"_{material.InternalName}", StringComparison.OrdinalIgnoreCase))
                {
                    return file;
                }
            }
        }
        catch
        {
            // Ignore directory access errors
        }

        return null;
    }

    /// <summary>
    /// Imports road smoothing settings from a JSON file into the material.
    /// </summary>
    private async Task<bool> ImportRoadSmoothingForMaterial(string filePath, TerrainMaterialItemExtended material)
    {
        try
        {
            var jsonContent = await File.ReadAllTextAsync(filePath);
            var jsonNode = System.Text.Json.Nodes.JsonNode.Parse(jsonContent);
            
            if (jsonNode == null)
                return false;

            // Enable road smoothing for this material
            material.IsRoadMaterial = true;

            // Import primary parameters
            if (jsonNode["roadWidthMeters"] != null)
                material.RoadWidthMeters = jsonNode["roadWidthMeters"]!.GetValue<float>();
            if (jsonNode["terrainAffectedRangeMeters"] != null)
                material.TerrainAffectedRangeMeters = jsonNode["terrainAffectedRangeMeters"]!.GetValue<float>();
            if (jsonNode["enableMaxSlopeConstraint"] != null)
                material.EnableMaxSlopeConstraint = jsonNode["enableMaxSlopeConstraint"]!.GetValue<bool>();
            if (jsonNode["roadMaxSlopeDegrees"] != null)
                material.RoadMaxSlopeDegrees = jsonNode["roadMaxSlopeDegrees"]!.GetValue<float>();
            if (jsonNode["sideMaxSlopeDegrees"] != null)
                material.SideMaxSlopeDegrees = jsonNode["sideMaxSlopeDegrees"]!.GetValue<float>();

            // Import algorithm settings
            if (jsonNode["approach"] != null && Enum.TryParse<RoadSmoothingApproach>(jsonNode["approach"]!.GetValue<string>(), out var approach))
                material.Approach = approach;
            if (jsonNode["blendFunctionType"] != null && Enum.TryParse<BlendFunctionType>(jsonNode["blendFunctionType"]!.GetValue<string>(), out var blendType))
                material.BlendFunctionType = blendType;
            if (jsonNode["crossSectionIntervalMeters"] != null)
                material.CrossSectionIntervalMeters = jsonNode["crossSectionIntervalMeters"]!.GetValue<float>();
            if (jsonNode["enableTerrainBlending"] != null)
                material.EnableTerrainBlending = jsonNode["enableTerrainBlending"]!.GetValue<bool>();

            // Import spline parameters
            var splineParams = jsonNode["splineParameters"];
            if (splineParams != null)
            {
                if (splineParams["tension"] != null)
                    material.SplineTension = splineParams["tension"]!.GetValue<float>();
                if (splineParams["continuity"] != null)
                    material.SplineContinuity = splineParams["continuity"]!.GetValue<float>();
                if (splineParams["bias"] != null)
                    material.SplineBias = splineParams["bias"]!.GetValue<float>();
                if (splineParams["useGraphOrdering"] != null)
                    material.UseGraphOrdering = splineParams["useGraphOrdering"]!.GetValue<bool>();
                if (splineParams["preferStraightThroughJunctions"] != null)
                    material.PreferStraightThroughJunctions = splineParams["preferStraightThroughJunctions"]!.GetValue<bool>();
                if (splineParams["densifyMaxSpacingPixels"] != null)
                    material.DensifyMaxSpacingPixels = splineParams["densifyMaxSpacingPixels"]!.GetValue<float>();
                if (splineParams["simplifyTolerancePixels"] != null)
                    material.SimplifyTolerancePixels = splineParams["simplifyTolerancePixels"]!.GetValue<float>();
                if (splineParams["bridgeEndpointMaxDistancePixels"] != null)
                    material.BridgeEndpointMaxDistancePixels = splineParams["bridgeEndpointMaxDistancePixels"]!.GetValue<float>();
                if (splineParams["minPathLengthPixels"] != null)
                    material.MinPathLengthPixels = splineParams["minPathLengthPixels"]!.GetValue<float>();
                if (splineParams["junctionAngleThreshold"] != null)
                    material.JunctionAngleThreshold = splineParams["junctionAngleThreshold"]!.GetValue<float>();
                if (splineParams["orderingNeighborRadiusPixels"] != null)
                    material.OrderingNeighborRadiusPixels = splineParams["orderingNeighborRadiusPixels"]!.GetValue<float>();
                if (splineParams["skeletonDilationRadius"] != null)
                    material.SkeletonDilationRadius = splineParams["skeletonDilationRadius"]!.GetValue<int>();
                if (splineParams["smoothingWindowSize"] != null)
                    material.SplineSmoothingWindowSize = splineParams["smoothingWindowSize"]!.GetValue<int>();
                if (splineParams["useButterworthFilter"] != null)
                    material.SplineUseButterworthFilter = splineParams["useButterworthFilter"]!.GetValue<bool>();
                if (splineParams["butterworthFilterOrder"] != null)
                    material.SplineButterworthFilterOrder = splineParams["butterworthFilterOrder"]!.GetValue<int>();
                if (splineParams["globalLevelingStrength"] != null)
                    material.GlobalLevelingStrength = splineParams["globalLevelingStrength"]!.GetValue<float>();
            }

            // Import DirectMask parameters
            var directMaskParams = jsonNode["directMaskParameters"];
            if (directMaskParams != null)
            {
                if (directMaskParams["smoothingWindowSize"] != null)
                    material.DirectMaskSmoothingWindowSize = directMaskParams["smoothingWindowSize"]!.GetValue<int>();
                if (directMaskParams["roadPixelSearchRadius"] != null)
                    material.RoadPixelSearchRadius = directMaskParams["roadPixelSearchRadius"]!.GetValue<int>();
                if (directMaskParams["useButterworthFilter"] != null)
                    material.DirectMaskUseButterworthFilter = directMaskParams["useButterworthFilter"]!.GetValue<bool>();
                if (directMaskParams["butterworthFilterOrder"] != null)
                    material.DirectMaskButterworthFilterOrder = directMaskParams["butterworthFilterOrder"]!.GetValue<int>();
            }

            // Import post-processing settings
            var postProcessing = jsonNode["postProcessing"];
            if (postProcessing != null)
            {
                if (postProcessing["enabled"] != null)
                    material.EnablePostProcessingSmoothing = postProcessing["enabled"]!.GetValue<bool>();
                if (postProcessing["smoothingType"] != null && Enum.TryParse<PostProcessingSmoothingType>(postProcessing["smoothingType"]!.GetValue<string>(), out var smoothingType))
                    material.SmoothingType = smoothingType;
                if (postProcessing["kernelSize"] != null)
                    material.SmoothingKernelSize = postProcessing["kernelSize"]!.GetValue<int>();
                if (postProcessing["sigma"] != null)
                    material.SmoothingSigma = postProcessing["sigma"]!.GetValue<float>();
                if (postProcessing["iterations"] != null)
                    material.SmoothingIterations = postProcessing["iterations"]!.GetValue<int>();
                if (postProcessing["maskExtensionMeters"] != null)
                    material.SmoothingMaskExtensionMeters = postProcessing["maskExtensionMeters"]!.GetValue<float>();
            }

            // Import debug settings
            var debug = jsonNode["debug"];
            if (debug != null)
            {
                if (debug["exportSmoothedHeightmapWithOutlines"] != null)
                    material.ExportSmoothedHeightmapWithOutlines = debug["exportSmoothedHeightmapWithOutlines"]!.GetValue<bool>();
                if (debug["exportSplineDebugImage"] != null)
                    material.ExportSplineDebugImage = debug["exportSplineDebugImage"]!.GetValue<bool>();
                if (debug["exportSkeletonDebugImage"] != null)
                    material.ExportSkeletonDebugImage = debug["exportSkeletonDebugImage"]!.GetValue<bool>();
                if (debug["exportSmoothedElevationDebugImage"] != null)
                    material.ExportSmoothedElevationDebugImage = debug["exportSmoothedElevationDebugImage"]!.GetValue<bool>();
            }

            // Set preset to Custom since we imported custom values
            material.SelectedPreset = RoadPresetType.Custom;

            return true;
        }
        catch (Exception ex)
        {
            PubSubChannel.SendMessage(PubSubMessageType.Warning,
                $"Failed to import road smoothing for '{material.InternalName}': {ex.Message}");
            return false;
        }
    }

    /// <summary>
    /// Sanitizes a filename by removing invalid characters (same as exporter).
    /// </summary>
    private string SanitizeFileName(string fileName)
    {
        var invalidChars = Path.GetInvalidFileNameChars();
        var result = fileName;
        
        foreach (var c in invalidChars)
        {
            result = result.Replace(c, '_');
        }
        
        result = result.Replace(' ', '_');
        result = result.Replace('-', '_');
        
        return result;
    }
}
