# DAE Collada Export Library - Implementation Plan

## Implementation Status

| Phase | Status | Description |
|-------|--------|-------------|
| Phase 1 | ? TODO | Project Setup and Core Abstractions |
| Phase 2 | ? TODO | Geometry Builder Implementation |
| Phase 3 | ? TODO | DAE Collada Exporter |
| Phase 4 | ? TODO | Road Network Mesh Generation |
| Phase 5 | ? TODO | Integration with BeamNgTerrainPoc |
| Phase 6 | ? TODO | Testing and Validation |

---

## Overview

This plan describes the implementation of a new library `BeamNG.Procedural3D` for generating 3D assets in DAE Collada format. The primary use case is exporting the smoothed road network generated by the road elevation smoothing pipeline.

### Goals

1. Create a reusable, standalone library for procedural 3D mesh generation
2. Export meshes to DAE Collada format for use in BeamNG.drive
3. First implementation: Export road network as 3D mesh with:
   - Road surface geometry based on cross-sections
   - Proper UV mapping for texturing
   - Support for road banking/superelevation
   - Optional shoulder/curb geometry

### Technology Stack

| Component | Library | Purpose |
|-----------|---------|---------|
| **Geometry Builder** | Custom + System.Numerics | Procedural mesh construction with Vector3, Matrix4x4 |
| **DAE Export** | AssimpNet | Industry-standard Collada export via Open Asset Import Library |
| **Math Utilities** | System.Numerics | SIMD-accelerated vector/matrix operations |

---

## Phase 1: Project Setup and Core Abstractions

### Step 1.1: Create New Library Project

**Goal**: Set up the new `BeamNG.Procedural3D` class library project.

**Tasks**:
1. Create new .NET 9 class library project: `BeamNG.Procedural3D`
2. Add to existing solution `BeamNG_LevelCleanUp.sln`
3. Configure project file with required NuGet packages:
   - `AssimpNet` (latest stable, e.g., 5.0.0-beta1)
   - `System.Numerics.Vectors` (included in .NET 9)
4. Set target framework to `net9.0-windows10.0.17763.0` for consistency

**Output**: New project folder structure:
```
BeamNG.Procedural3D/
??? BeamNG.Procedural3D.csproj
??? Core/
?   ??? Vertex.cs
?   ??? Triangle.cs
?   ??? Mesh.cs
??? Builders/
?   ??? (Phase 2)
??? Exporters/
?   ??? (Phase 3)
??? RoadMesh/
    ??? (Phase 4)
```

---

### Step 1.2: Define Core Data Structures

**Goal**: Create the fundamental mesh data structures.

**File**: `Core/Vertex.cs`
```csharp
namespace BeamNG.Procedural3D.Core;

using System.Numerics;

/// <summary>
/// Represents a vertex with position, normal, and UV coordinates.
/// </summary>
public readonly struct Vertex
{
    public Vector3 Position { get; init; }
    public Vector3 Normal { get; init; }
    public Vector2 UV { get; init; }
    
    public Vertex(Vector3 position, Vector3 normal, Vector2 uv)
    {
        Position = position;
        Normal = normal;
        UV = uv;
    }
}
```

**File**: `Core/Triangle.cs`
```csharp
namespace BeamNG.Procedural3D.Core;

/// <summary>
/// Represents a triangle face as three vertex indices.
/// </summary>
public readonly struct Triangle
{
    public int V0 { get; init; }
    public int V1 { get; init; }
    public int V2 { get; init; }
    
    public Triangle(int v0, int v1, int v2)
    {
        V0 = v0;
        V1 = v1;
        V2 = v2;
    }
}
```

**File**: `Core/Mesh.cs`
```csharp
namespace BeamNG.Procedural3D.Core;

/// <summary>
/// Represents a 3D mesh with vertices, triangles, and optional material.
/// </summary>
public class Mesh
{
    public string Name { get; set; } = "Mesh";
    public List<Vertex> Vertices { get; } = new();
    public List<Triangle> Triangles { get; } = new();
    public string? MaterialName { get; set; }
}
```

---

### Step 1.3: Define Builder Interface

**Goal**: Create the abstraction for mesh builders.

**File**: `Builders/IMeshBuilder.cs`
```csharp
namespace BeamNG.Procedural3D.Builders;

using BeamNG.Procedural3D.Core;

/// <summary>
/// Interface for procedural mesh builders.
/// </summary>
public interface IMeshBuilder
{
    /// <summary>
    /// Builds the mesh from the configured parameters.
    /// </summary>
    Mesh Build();
    
    /// <summary>
    /// Resets the builder for reuse.
    /// </summary>
    void Clear();
}
```

---

### Step 1.4: Define Exporter Interface

**Goal**: Create the abstraction for mesh exporters.

**File**: `Exporters/IMeshExporter.cs`
```csharp
namespace BeamNG.Procedural3D.Exporters;

using BeamNG.Procedural3D.Core;

/// <summary>
/// Interface for exporting meshes to various file formats.
/// </summary>
public interface IMeshExporter
{
    /// <summary>
    /// Exports a single mesh to a file.
    /// </summary>
    void Export(Mesh mesh, string filePath);
    
    /// <summary>
    /// Exports multiple meshes to a single file (scene).
    /// </summary>
    void Export(IEnumerable<Mesh> meshes, string filePath);
    
    /// <summary>
    /// Gets the file extension for this exporter (e.g., ".dae").
    /// </summary>
    string FileExtension { get; }
}
```

---

## Phase 2: Geometry Builder Implementation

### Step 2.1: Create Base MeshBuilder Class

**Goal**: Implement a general-purpose mesh builder with common operations.

**File**: `Builders/MeshBuilder.cs`

**Responsibilities**:
- Add vertices with automatic index tracking
- Add triangles and quads
- Calculate normals (per-face or smooth)
- Transform vertices (translate, rotate, scale)
- Merge meshes

**Key Methods**:
```csharp
public class MeshBuilder : IMeshBuilder
{
    // Add a vertex, returns its index
    public int AddVertex(Vector3 position, Vector3 normal, Vector2 uv);
    
    // Add a triangle by vertex indices
    public void AddTriangle(int v0, int v1, int v2);
    
    // Add a quad (converted to 2 triangles)
    public void AddQuad(int v0, int v1, int v2, int v3);
    
    // Extrude a 2D profile along a path
    public void AddExtrusion(IReadOnlyList<Vector2> profile, IReadOnlyList<Vector3> path, IReadOnlyList<Vector3> normals);
    
    // Create a lofted surface between two profiles
    public void AddLoft(IReadOnlyList<Vector3> profile1, IReadOnlyList<Vector3> profile2);
    
    // Calculate flat normals (per-face)
    public void CalculateFlatNormals();
    
    // Calculate smooth normals (averaged per-vertex)
    public void CalculateSmoothNormals();
    
    // Apply transformation matrix to all vertices
    public void Transform(Matrix4x4 matrix);
    
    // Build final mesh
    public Mesh Build();
}
```

---

### Step 2.2: Implement UV Mapping Utilities

**Goal**: Provide UV coordinate generation for common mapping scenarios.

**File**: `Builders/UVMapper.cs`

**Mapping Types**:
- **Planar**: Project onto XY, XZ, or YZ plane
- **Box**: 6-sided box projection
- **Cylindrical**: Wrap around Y axis
- **Road Surface**: Along-road (U) and across-road (V) mapping

```csharp
public static class UVMapper
{
    // Planar projection
    public static Vector2 PlanarXZ(Vector3 position, float scaleU, float scaleV);
    
    // Road surface: U = distance along road, V = position across road
    public static Vector2 RoadSurface(float distanceAlongRoad, float positionAcrossRoad, float textureRepeatMeters);
}
```

---

### Step 2.3: Implement Primitive Builders (Optional but Useful)

**Goal**: Provide builders for common primitive shapes for testing and future use.

**File**: `Builders/PrimitiveBuilder.cs`

```csharp
public static class PrimitiveBuilder
{
    public static Mesh CreateBox(Vector3 center, Vector3 size);
    public static Mesh CreateCylinder(Vector3 start, Vector3 end, float radius, int segments);
    public static Mesh CreatePlane(Vector3 center, Vector3 normal, float width, float height);
}
```

---

## Phase 3: DAE Collada Exporter

### Step 3.1: Implement AssimpNet-Based DAE Exporter

**Goal**: Create the Collada exporter using AssimpNet.

**File**: `Exporters/ColladaExporter.cs`

**Implementation**:
```csharp
using Assimp;

public class ColladaExporter : IMeshExporter
{
    public string FileExtension => ".dae";
    
    public void Export(Mesh mesh, string filePath)
    {
        Export(new[] { mesh }, filePath);
    }
    
    public void Export(IEnumerable<Mesh> meshes, string filePath)
    {
        var scene = new Scene();
        scene.RootNode = new Node("RootNode");
        
        // Add default material if none specified
        var defaultMaterial = new Material { Name = "DefaultMaterial" };
        scene.Materials.Add(defaultMaterial);
        
        int meshIndex = 0;
        foreach (var mesh in meshes)
        {
            var assimpMesh = ConvertToAssimpMesh(mesh, meshIndex);
            scene.Meshes.Add(assimpMesh);
            scene.RootNode.MeshIndices.Add(meshIndex);
            meshIndex++;
        }
        
        using var context = new AssimpContext();
        context.ExportFile(scene, filePath, "collada");
    }
    
    private Assimp.Mesh ConvertToAssimpMesh(Core.Mesh mesh, int materialIndex)
    {
        var assimpMesh = new Assimp.Mesh(mesh.Name, PrimitiveType.Triangle);
        assimpMesh.MaterialIndex = materialIndex;
        
        // Convert vertices
        foreach (var vertex in mesh.Vertices)
        {
            assimpMesh.Vertices.Add(new Vector3D(vertex.Position.X, vertex.Position.Y, vertex.Position.Z));
            assimpMesh.Normals.Add(new Vector3D(vertex.Normal.X, vertex.Normal.Y, vertex.Normal.Z));
            assimpMesh.TextureCoordinateChannels[0].Add(new Vector3D(vertex.UV.X, vertex.UV.Y, 0));
        }
        
        // Convert triangles to faces
        foreach (var tri in mesh.Triangles)
        {
            var face = new Face();
            face.Indices.Add(tri.V0);
            face.Indices.Add(tri.V1);
            face.Indices.Add(tri.V2);
            assimpMesh.Faces.Add(face);
        }
        
        return assimpMesh;
    }
}
```

---

### Step 3.2: Add Material Support

**Goal**: Support material definitions in exported DAE files.

**File**: `Core/Material.cs`
```csharp
public class Material
{
    public string Name { get; set; } = "Material";
    public Vector3 DiffuseColor { get; set; } = new(0.8f, 0.8f, 0.8f);
    public Vector3 SpecularColor { get; set; } = new(0.2f, 0.2f, 0.2f);
    public float Shininess { get; set; } = 32f;
    public string? DiffuseTexturePath { get; set; }
}
```

**Update** `ColladaExporter.cs` to handle materials with texture references.

---

### Step 3.3: Add Export Options

**Goal**: Provide configuration options for the export process.

**File**: `Exporters/ColladaExportOptions.cs`
```csharp
public class ColladaExportOptions
{
    /// <summary>
    /// Apply Y-up to Z-up coordinate conversion (BeamNG uses Z-up).
    /// </summary>
    public bool ConvertToZUp { get; set; } = true;
    
    /// <summary>
    /// Scale factor applied to all vertices.
    /// </summary>
    public float ScaleFactor { get; set; } = 1.0f;
    
    /// <summary>
    /// Include UV coordinates in export.
    /// </summary>
    public bool IncludeUVs { get; set; } = true;
    
    /// <summary>
    /// Include vertex normals in export.
    /// </summary>
    public bool IncludeNormals { get; set; } = true;
}
```

---

## Phase 4: Road Network Mesh Generation

### Step 4.1: Define Road Mesh Input Data

**Goal**: Create data structures for road mesh generation input.

**File**: `RoadMesh/RoadCrossSection.cs`
```csharp
using System.Numerics;

namespace BeamNG.Procedural3D.RoadMesh;

/// <summary>
/// Represents a cross-section of the road at a specific point.
/// This mirrors the data from the road smoothing pipeline.
/// </summary>
public class RoadCrossSection
{
    /// <summary>Position on the road centerline (X, Y in world coordinates).</summary>
    public Vector2 CenterPoint { get; set; }
    
    /// <summary>Elevation at the road center.</summary>
    public float CenterElevation { get; set; }
    
    /// <summary>Unit vector along the road direction.</summary>
    public Vector2 TangentDirection { get; set; }
    
    /// <summary>Unit vector perpendicular to the road (left side).</summary>
    public Vector2 NormalDirection { get; set; }
    
    /// <summary>Road width at this cross-section.</summary>
    public float WidthMeters { get; set; }
    
    /// <summary>Banking angle in radians (positive = left side higher).</summary>
    public float BankAngleRadians { get; set; }
    
    /// <summary>Distance along the road from start (for UV mapping).</summary>
    public float DistanceAlongRoad { get; set; }
    
    /// <summary>Optional: Left edge elevation (if constrained).</summary>
    public float? LeftEdgeElevation { get; set; }
    
    /// <summary>Optional: Right edge elevation (if constrained).</summary>
    public float? RightEdgeElevation { get; set; }
}
```

---

### Step 4.2: Implement Road Mesh Builder

**Goal**: Create a specialized mesh builder for road surfaces.

**File**: `RoadMesh/RoadMeshBuilder.cs`

**Algorithm**:
1. For each consecutive pair of cross-sections, create a quad (2 triangles)
2. Calculate edge positions using: `edge = center ± (normal * halfWidth)`
3. Apply banking: `edgeElevation = centerElevation ± tan(bankAngle) * halfWidth`
4. Generate UV coordinates: U = distance along road, V = 0 (left) to 1 (right)
5. Calculate normals: cross product of edge vectors

```csharp
public class RoadMeshBuilder : IMeshBuilder
{
    private readonly List<RoadCrossSection> _crossSections = new();
    private readonly RoadMeshOptions _options = new();
    
    public RoadMeshBuilder WithOptions(RoadMeshOptions options);
    public RoadMeshBuilder AddCrossSection(RoadCrossSection crossSection);
    public RoadMeshBuilder AddCrossSections(IEnumerable<RoadCrossSection> crossSections);
    
    public Mesh Build()
    {
        var mesh = new Mesh { Name = _options.MeshName };
        
        if (_crossSections.Count < 2)
            return mesh;
        
        for (int i = 0; i < _crossSections.Count; i++)
        {
            var cs = _crossSections[i];
            
            // Calculate left and right edge positions
            var leftPos = CalculateLeftEdge(cs);
            var rightPos = CalculateRightEdge(cs);
            
            // Calculate left and right elevations (with banking)
            var leftElev = CalculateLeftElevation(cs);
            var rightElev = CalculateRightElevation(cs);
            
            // Create 3D positions
            var leftVertex = new Vector3(leftPos.X, leftPos.Y, leftElev);
            var rightVertex = new Vector3(rightPos.X, rightPos.Y, rightElev);
            
            // UV coordinates
            var leftUV = new Vector2(cs.DistanceAlongRoad / _options.TextureRepeatMeters, 0f);
            var rightUV = new Vector2(cs.DistanceAlongRoad / _options.TextureRepeatMeters, 1f);
            
            // Add vertices (normals calculated later)
            mesh.Vertices.Add(new Vertex(leftVertex, Vector3.UnitZ, leftUV));
            mesh.Vertices.Add(new Vertex(rightVertex, Vector3.UnitZ, rightUV));
        }
        
        // Create triangles between consecutive cross-sections
        for (int i = 0; i < _crossSections.Count - 1; i++)
        {
            int baseIdx = i * 2;
            // Quad: [left0, right0, left1, right1]
            // Triangle 1: left0, right0, left1
            mesh.Triangles.Add(new Triangle(baseIdx, baseIdx + 1, baseIdx + 2));
            // Triangle 2: right0, right1, left1
            mesh.Triangles.Add(new Triangle(baseIdx + 1, baseIdx + 3, baseIdx + 2));
        }
        
        // Recalculate proper normals
        CalculateNormals(mesh);
        
        return mesh;
    }
}
```

---

### Step 4.3: Road Mesh Options

**File**: `RoadMesh/RoadMeshOptions.cs`
```csharp
public class RoadMeshOptions
{
    /// <summary>Name for the generated mesh.</summary>
    public string MeshName { get; set; } = "RoadMesh";
    
    /// <summary>Material name to assign to the mesh.</summary>
    public string MaterialName { get; set; } = "road_asphalt";
    
    /// <summary>UV repeat distance in meters (default: 10m).</summary>
    public float TextureRepeatMeters { get; set; } = 10f;
    
    /// <summary>Generate shoulder geometry alongside the road.</summary>
    public bool IncludeShoulders { get; set; } = false;
    
    /// <summary>Shoulder width in meters (if shoulders enabled).</summary>
    public float ShoulderWidthMeters { get; set; } = 1.5f;
    
    /// <summary>Shoulder drop height in meters.</summary>
    public float ShoulderDropMeters { get; set; } = 0.1f;
    
    /// <summary>Generate curb geometry.</summary>
    public bool IncludeCurbs { get; set; } = false;
    
    /// <summary>Curb height in meters.</summary>
    public float CurbHeightMeters { get; set; } = 0.15f;
    
    /// <summary>Calculate smooth normals (true) or flat normals (false).</summary>
    public bool SmoothNormals { get; set; } = true;
}
```

---

### Step 4.4: Implement Shoulder and Curb Geometry (Optional)

**Goal**: Extend road mesh to include shoulder and curb geometry.

**Tasks**:
1. Add shoulder triangles adjacent to main road surface
2. Add vertical curb faces if curbs enabled
3. Ensure UV continuity between road and shoulder
4. Handle banking transitions properly

---

## Phase 5: Integration with BeamNgTerrainPoc

### Step 5.1: Add Project Reference

**Goal**: Reference the new library from BeamNgTerrainPoc.

**Tasks**:
1. Add project reference: `BeamNgTerrainPoc` ? `BeamNG.Procedural3D`
2. Ensure build order is correct

---

### Step 5.2: Create Cross-Section Converter

**Goal**: Convert from pipeline's `UnifiedCrossSection` to `RoadCrossSection`.

**File**: `BeamNgTerrainPoc/Terrain/Export/CrossSectionConverter.cs`

```csharp
public static class CrossSectionConverter
{
    public static RoadCrossSection Convert(UnifiedCrossSection source, float distanceAlongRoad)
    {
        return new RoadCrossSection
        {
            CenterPoint = source.CenterPoint,
            CenterElevation = source.TargetElevation,
            TangentDirection = source.TangentDirection,
            NormalDirection = source.NormalDirection,
            WidthMeters = source.WidthMeters,
            BankAngleRadians = source.BankAngleRadians,
            DistanceAlongRoad = distanceAlongRoad,
            LeftEdgeElevation = source.ConstrainedLeftEdgeElevation,
            RightEdgeElevation = source.ConstrainedRightEdgeElevation
        };
    }
    
    public static List<RoadCrossSection> ConvertPath(IReadOnlyList<UnifiedCrossSection> path, float crossSectionInterval)
    {
        var result = new List<RoadCrossSection>();
        float distance = 0;
        
        foreach (var cs in path)
        {
            if (!float.IsNaN(cs.TargetElevation) && cs.TargetElevation > -1000)
            {
                result.Add(Convert(cs, distance));
            }
            distance += crossSectionInterval;
        }
        
        return result;
    }
}
```

---

### Step 5.3: Create Road Network Exporter Service

**Goal**: Orchestrate the export of the entire road network.

**File**: `BeamNgTerrainPoc/Terrain/Export/RoadNetworkDaeExporter.cs`

```csharp
public class RoadNetworkDaeExporter
{
    public void Export(RoadGeometry roadGeometry, string outputPath, RoadMeshOptions options)
    {
        var meshes = new List<Mesh>();
        
        // Group cross-sections by PathId
        var paths = roadGeometry.CrossSections
            .GroupBy(cs => cs.PathId)
            .OrderBy(g => g.Key);
        
        foreach (var pathGroup in paths)
        {
            var crossSections = CrossSectionConverter.ConvertPath(
                pathGroup.OrderBy(cs => cs.LocalIndex).ToList(),
                roadGeometry.CrossSectionIntervalMeters);
            
            if (crossSections.Count < 2)
                continue;
            
            var builder = new RoadMeshBuilder()
                .WithOptions(options with { MeshName = $"Road_Path{pathGroup.Key}" })
                .AddCrossSections(crossSections);
            
            meshes.Add(builder.Build());
        }
        
        // Export all road meshes to single DAE file
        var exporter = new ColladaExporter();
        exporter.Export(meshes, outputPath);
    }
}
```

---

### Step 5.4: Add Export Option to Pipeline

**Goal**: Integrate DAE export into the existing terrain generation workflow.

**Tasks**:
1. Add export parameters to `TerrainCreationParameters`:
   ```csharp
   public bool ExportRoadMeshDae { get; set; } = false;
   public string RoadMeshOutputPath { get; set; } = "road_network.dae";
   public RoadMeshOptions RoadMeshOptions { get; set; } = new();
   ```

2. Call exporter after road smoothing completes (in orchestrator)

---

## Phase 6: Testing and Validation

### Step 6.1: Unit Tests for Core Components

**Goal**: Verify core mesh building functionality.

**Test Cases**:
- `MeshBuilder.AddTriangle` creates valid triangle
- `MeshBuilder.AddQuad` creates 2 triangles with correct winding
- `MeshBuilder.CalculateSmoothNormals` produces normalized vectors
- `RoadMeshBuilder` with 2 cross-sections produces 2 triangles
- `RoadMeshBuilder` handles banking correctly

---

### Step 6.2: Integration Test with Sample Road

**Goal**: Generate a DAE from a known road configuration and validate in 3D viewer.

**Test Procedure**:
1. Create a simple S-curve road with 100 cross-sections
2. Apply mild banking on curves
3. Export to DAE
4. Load in Blender or 3D viewer
5. Verify:
   - Mesh is watertight (no holes)
   - Normals point outward
   - UV coordinates are continuous
   - Banking is visible

---

### Step 6.3: BeamNG.drive Import Test

**Goal**: Verify exported DAE works in BeamNG.drive.

**Test Procedure**:
1. Export road mesh from real terrain generation
2. Copy DAE to BeamNG level's `art/shapes/` folder
3. Place as TSStatic in world editor
4. Verify:
   - Model loads without errors
   - Textures can be applied
   - Scale and orientation are correct
   - Road is driveable (collision from DAE or separate collision mesh)

---

## Dependencies Summary

### NuGet Packages for BeamNG.Procedural3D

```xml
<PackageReference Include="AssimpNet" Version="5.0.0-beta1" />
```

### Native Dependencies

AssimpNet requires the native Assimp library. Options:
1. **NuGet native package**: `Assimp.Native.Windows` (auto-deployed)
2. **Manual deployment**: Copy `assimp.dll` to output directory

---

## Future Extensions

After initial implementation, the library can be extended for:

1. **Terrain Mesh Export**: Export terrain heightmap as DAE mesh
2. **Building Generation**: Procedural buildings from footprints
3. **Vegetation Placement**: Export forest item positions
4. **Bridge Generation**: Procedural bridges over terrain gaps
5. **Tunnel Generation**: Underground road sections
6. **LOD Generation**: Multiple detail levels for performance
7. **Collision Mesh**: Simplified collision geometry

---

## File Structure Summary

```
BeamNG.Procedural3D/
??? BeamNG.Procedural3D.csproj
??? Core/
?   ??? Vertex.cs
?   ??? Triangle.cs
?   ??? Mesh.cs
?   ??? Material.cs
??? Builders/
?   ??? IMeshBuilder.cs
?   ??? MeshBuilder.cs
?   ??? UVMapper.cs
?   ??? PrimitiveBuilder.cs
??? Exporters/
?   ??? IMeshExporter.cs
?   ??? ColladaExporter.cs
?   ??? ColladaExportOptions.cs
??? RoadMesh/
    ??? RoadCrossSection.cs
    ??? RoadMeshBuilder.cs
    ??? RoadMeshOptions.cs

BeamNgTerrainPoc/
??? Terrain/
    ??? Export/
        ??? CrossSectionConverter.cs
        ??? RoadNetworkDaeExporter.cs
```

---

## Coding Guidelines

1. **Use file-scoped namespaces** throughout
2. **Use `readonly struct`** for small immutable types (Vertex, Triangle)
3. **Use `init` properties** for immutable configuration
4. **Follow existing project patterns** for logging and error handling
5. **Use `System.Numerics`** for all vector/matrix operations
6. **Validate inputs** - throw `ArgumentException` for invalid data
7. **Document public APIs** with XML comments
